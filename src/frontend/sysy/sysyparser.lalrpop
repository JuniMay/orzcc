use crate::frontend::ast::*;

grammar;

match {
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},
  _
}
// 编译单元 CompUnit → [ CompUnit ] ( Decl | FuncDef )
pub CompUnit: CompUnit = {
  <(CompUnitItem)*>=>CompUnit{<>}
}
// 编译单元项 CompUnitItem → Decl | FuncDef
pub CompUnitItem: CompUnitItem = {
  Decl,
  FuncDef
}

// 声明 Decl → ConstDecl | VarDecl
pub Decl: Decl = {
  ConstDecl,
  VarDecl,
}

// 常量声明 ConstDecl → 'const' BType ConstDef { ',' ConstDef } ';'
pub ConstDecl: ConstDecl = {
  "const" <b:BType> <c:ConstDef> <mut v:("," <ConstDef>)*> ";"
  =>match v{
    Some(v)=>{
        v.push(c);
        ConstDecl::ConstDecl(b,v)
    }
    None=>ConstDecl::ConstDecl(b,c)
  }

}

// 基本类型 BType → 'int' | 'float'
pub BType: BType = {
  "int" => BType::Int,
  "float" => BType::Float
}

// 常量定义 ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal
pub ConstDef: ConstDef = {
  <i:Ident> <mut v:("[" <ConstExp> "]" )* > "=" <c:ConstInitVal>
  =>match v{
    Some(v)=>{
      ConstDef::ConstDef(i,v,c)
    }
    None=>ConstDef::ConstDef(i,vec![],c)
  }
}

// 常量初值 ConstInitVal → ConstExp | '{' [ ConstInitVal { ',' ConstInitVal } ] '}'
pub ConstInitVal: ConstInitVal = {
  <c:ConstExp> => ConstInitVal::ConstExp(c),
  "{" <ci:ConstInitVal> <mut v:("," <ConstInitVal>)*> "}"
  =>match ci{
    Some(ci)=>match v
    {
      Some(v)=>{
        v.push(ci);
        ConstInitVal::ConstInitVal(c,v)
      }
      None=>ConstInitVal::ConstInitVal(c,vec![ci])
    }
    None=>ConstInitVal::ConstInitVal(c,vec![])
  }
}

// 变量声明 VarDecl → BType VarDef { ',' VarDef } ';'
pub VarDecl: VarDecl = {
  <b:BType> <vd:VarDef> <mut v:("," <VarDef>)*> ";"
  =>match v{
    Some(v)=>{
      v.push(vd);
      VarDecl::VarDecl(b,v)
    }
    None=>VarDecl::VarDecl(b,vd)
  }
}

// 变量定义 VarDef → Ident { '[' ConstExp ']' } | Ident { '[' ConstExp ']' } '=' InitVal
pub VarDef: VarDef = {
  <i:Ident> <mut v:("[" <ConstExp> "]" )* > ("=" <iv:InitVal>)?
  =>match v{
    Some(v)=>{
      VarDef::VarDef(i,v,iv)
    }
    None=>VarDef::VarDef(i,vec![],iv)
  }
}

// 变量初值 InitVal → Exp | '{' [ InitVal { ',' InitVal } ] '}'
pub InitVal: InitVal = {
  <e:Exp> => InitVal::Exp(e),
  "{" <iv:InitVal> <mut v:("," <InitVal>)*> "}"
  =>match iv{
    Some(iv)=>match v
    {
      Some(v)=>{
        v.push(iv);
        InitVal::InitVal(e,v)
      }
      None=>InitVal::InitVal(e,vec![iv])
    }
    None=>InitVal::InitVal(e,vec![])
  }
}

// 函数定义 FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
pub FuncDef: FuncDef={
  <ft:FuncType> <i:Ident> "(" ")" <b:Block> => {
    FuncDef{ functype: ft, ident: i, funcfparams: Vec::new(), block: b }
  },
  <ft:FuncType> <i:Ident> "(" <fps:FuncFParams> ")" <b:Block> => {
    FuncDef{ functype: ft, ident: i, funcfparams: fps, block: b }
  },
}

// 函数类型 FuncType → 'void' | 'int' | 'float'
pub FuncType: FuncType = {
  "void" => FuncType::Void,
  "int" => FuncType::Int,
  "float" => FuncType::Float
}

// 函数形参表 FuncFParams → FuncFParam { ',' FuncFParam }
pub FuncFParams: FuncFParams={
  <fp:FuncFParam> <mut v:("," <FuncFParam>)*>
  => match v {
  Some(v)=>{
    v.push(fp);
    FuncFParams::FuncFParams(v)
  }
  None=>FuncFParams::FuncFParams(fp)
  }
}

// 函数形参 FuncFParam → BType Ident ['[' ']' { '[' Exp ']' }]
pub FuncFParam: FuncFParam={
  <btype:BType> <ident:Ident> <exp: ("[" "]" <("[" <Exp> "]")*>)?> => {
    FuncFParam { <> }
  },
}

// 语句块 Block → '{' { BlockItem } '}'
pub Block: Block={
  "{" <blockitem: (BlockItem)*> "}" => {
    Block{<>}
  }
}

// 语句块项 BlockItem → Decl | Stmt
pub BlockItem: BlockItem = {
  Decl,
  Stmt,
}

// 语句 Stmt → LVal '=' Exp ';' | [Exp] ';' | Block
//             | 'if' '( Cond ')' Stmt [ 'else' Stmt ]
//             | 'while' '(' Cond ')' Stmt
//             | 'break' ';' | 'continue' ';'
//             | 'return' [Exp] ';'
pub Stmt: Stmt={

}

// 表达式 Exp → AddExp 注：SysY表达式是 int/float型表达式
pub Exp: Exp = <addexp:AddExp> => Exp{<>};

// 条件表达式 Cond → LOrExp
pub Cond: Cond = <lorexp:LOrExp> => Cond{<>};

// 左值表达式 LVal → Ident {'[' Exp ']'}
pub LVal: LVal = <ident: Ident> <exp: ("[" <Exp> "]")*> => LVal { <> };

// 基本表达式 PrimaryExp → '(' Exp ')' | LVal | Number
pub PrimaryExp: PrimaryExp = {
  "(" <Exp> ")" => PrimaryExp::Exp(<>),
  LVal => PrimaryExp::LVal(<>),
  Number => PrimaryExp::Number(<>),
}

// 数值 Number → IntConst | floatConst
pub Number: Number = {
  <n:Int> => Number::IntConst(n),
  <f:Float> => Number::FloatConst(f),
}

Int: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}

Float: f32 = {
  r"((([0-9]*[.][0-9]*([eE][+-]?[0-9]+)?)|([0-9]+[eE][+-]?[0-9]+))[fLlL]?)" => <>.parse::<f32>().unwrap(),
  r"(0[xX](([0-9A-Fa-f]*[.][0-9A-Fa-f]*([pP][+-]?[0-9]+)?)|([0-9A-Fa-f]+[pP][+-]?[0-9]+))[fLlL]?)" => todo!(),
}

// 一元表达式 UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp
pub UnaryExp: UnaryExp = {
  PrimaryExp => UnaryExp::Primary(<>),
  <i: Ident> "(" ")" => UnaryExp::FuncCall(FuncCall { i, exp: Vec::new() }),
  <i: Ident> "(" <e: Exp> <mut exp: ("," <Exp>)*> ")" => {
    exp.insert(0, e);
    UnaryExp::FuncCall(FuncCall { i, exp })
  },
  "+" <UnaryExp> => <>,
  <uop: UnaryOp> <uexp: UnaryExp> => UnaryExp::UnaryOp(uop, Box::new(uexp)),
}

// 单目运算符 UnaryOp → '+' | '−' | '!' 注：'!'仅出现在仅出现在条件表达式中条件表达式中，其中 '+' 可以不考虑
pub UnaryOp: UnaryOp = {
  "-" => UnaryOp::Neg,
  "!" => UnaryOp::Not,
}

// 乘除模表达式 MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
pub MulExp: MulExp = {
  UnaryExp => MulExp::UnaryExp(<>),
  <me: MulExp> "*" <ue: UnaryExp> => {
    MulExp::MulUExp(me, "*", ue)
  },
  <me: MulExp> "/" <ue: UnaryExp> => {
    MulExp::MulUExp(me, "/", ue)
  },
  <me: MulExp> "%" <ue: UnaryExp> => {
    MulExp::MulUExp(me, "%", ue)
  },
}

// 加减表达式 AddExp → MulExp | AddExp ('+' | '−') MulExp
pub AddExp: AddExp = {
  MulExp => AddExp::MulExp(<>),
  <ae: AddExp> "+" <me: MulExp> => {
    AddExp::AddMExp(ae, "+", me)
  },
  <ae: AddExp> "-" <me: MulExp> => {
    AddExp::AddMExp(ae, "-", me)
  },
}

// 关系表达式 RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp
pub RelExp: RelExp = {
  AddExp => RelExp::AddExp(<>),
  <re: RelExp> "<" <ae: AddExp> => {
    RelExp::RelAExp(re, "<", ae)
  },
  <re: RelExp> ">" <ae: AddExp> => {
    RelExp::RelAExp(re, ">", ae)
  },
  <re: RelExp> "<=" <ae: AddExp> => {
    RelExp::RelAExp(re, "<=", ae)
  },
  <re: RelExp> ">=" <ae: AddExp> => {
    RelExp::RelAExp(re, ">=", ae)
  },
}

// 相等性表达式 EqExp → RelExp | EqExp ('==' | '!=') RelExp
pub EqExp: EqExp = {
  RelExp => EqExp::RelExp(<>),
  <ee: EqExp> "==" <re: RelExp> => {
    EqExp::EqRExp(ee, "==", re)
  },
  <ee: EqExp> "!=" <re: RelExp> => {
    EqExp::EqRExp(ee, "!=", re)
  },
}

// 逻辑与表达式 LAndExp → EqExp | LAndExp '&&' EqExp
LAndExp: LAndExp = {
  EqExp => LAndExp::EqExp(<>),
  <le: LAndExp> "&&" <ee: EqExp> => {
    LAndExp::LAndEExp(le, "&&",ee)
  },
}

// 逻辑或表达式 LOrExp → LAndExp | LOrExp '||' LAndExp
LOrExp: LOrExp = {
  LAndExp => LOrExp::LAndExp(<>),
  <loe: LOrExp> "||" <lae: LAndExp> => {
    LOrExp::LOrLExp(loe,"||" ,lae)
  },
}

// 常量表达式 ConstExp → AddExp
pub ConstExp: ConstExp = <addexp:AddExp> => ConstExp{<>};

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();
