use crate::frontend::ast::*;
//use hexponent::FloatLiteral;

grammar;

match {
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {},
  _
}

// Compilation unit CompUnit → [ CompUnit ] ( Decl | FuncDef )
pub CompUnit: CompUnit = {
  <item: (CompUnitItem)*> => CompUnit { <> }
}

// Compilation unit item CompUnitItem → Decl | FuncDef
pub CompUnitItem: CompUnitItem = {
  <d:Decl> => CompUnitItem::Decl(d),
  <f:FuncDef> => CompUnitItem::FuncDef(f)
}

// Declaration Decl → ConstDecl | VarDecl
pub Decl: Decl = {
  <d:ConstDecl> => Decl::ConstDecl(d),
  <v:VarDecl> => Decl::VarDecl(v)
}

// Type BasicType → 'void' | 'int' | 'float'
pub BasicType: BasicType = {
  "void" => BasicType::Void,
  "int" => BasicType::Int,
  "float" => BasicType::Float
}

// Constant declaration ConstDecl → 'const' BasicType ConstDef { ',' ConstDef } ';'
pub ConstDecl: ConstDecl = {
  "const" <t:BasicType> <c:ConstDef> <mut v:("," <ConstDef>)*> ";" => {
    v.insert(0, c); 
    ConstDecl { basictype: t, constdef: v } 
  }
}

// Constant definition ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal
pub ConstDef: ConstDef = {
  <i:Ident> <v:("[" <ConstExp> "]" )* > "=" <c:ConstInitVal> => {
    ConstDef { ident: i, constexp: v, constinitval: c }
  }
}

// Constant value ConstInitVal → ConstExp | '{' [ ConstInitVal { ',' ConstInitVal } ] '}'
pub ConstInitVal: ConstInitVal = {
  <c:ConstExp> => ConstInitVal::ConstExp(c),
  "{" <ci:ConstInitVal> <mut v:("," <ConstInitVal>)*> "}" => {
    v.insert(0, ci);
    ConstInitVal::ConstInitVal(v)
  },
  "{" "}" => ConstInitVal::ConstInitVal(Vec::new())
}

// Variable declaration VarDecl → BasicType VarDef { ',' VarDef } ';'
pub VarDecl: VarDecl = {
  <t:BasicType> <vd:VarDef> <mut v:("," <VarDef>)*> ";" => {
    v.insert(0, vd); 
    VarDecl { basictype: t, vardef: v } 
  }
}

// Variable definition VarDef → Ident { '[' ConstExp ']' } | Ident { '[' ConstExp ']' } '=' InitVal
pub VarDef: VarDef = {
  <i:Ident> <v:("[" <ConstExp> "]" )* > <ini: ("=" <InitVal>)?> => {
    VarDef { ident: i, constexp: v, initval: ini }
  }
}

// Variable initial value InitVal → Exp | '{' [ InitVal { ',' InitVal } ] '}'
pub InitVal: InitVal = {
  <e:Exp> => InitVal::Exp(e),
  "{" <iv:InitVal> <mut v:("," <InitVal>)*> "}" => {
    v.insert(0, iv);
    InitVal::InitVal(v)
  },
  "{" "}" => InitVal::InitVal(Vec::new())
}

// Function definition FuncDef → BasicType Ident '(' [FuncFParams] ')' Block
pub FuncDef: FuncDef={
  <t:BasicType> <i:Ident> "(" ")" <b:Block> => {
    FuncDef{ basictype: t, ident: i, funcfparams: FuncFParams { funcfparam: vec![] }, block: b }
  },
  <t:BasicType> <i:Ident> "(" <fps:FuncFParams> ")" <b:Block> => {
    FuncDef{ basictype: t, ident: i, funcfparams: fps, block: b }
  },
}

// Function formal parameter table FuncFParams → FuncFParam { ',' FuncFParam }
pub FuncFParams: FuncFParams={
  <fp:FuncFParam> <mut v:("," <FuncFParam>)*> => {
    v.insert(0, fp);
    FuncFParams { funcfparam:v }
  }
}

// Function formal parameter FuncFParam → BasicType Ident ['[' ']' { '[' Exp ']' }]
pub FuncFParam: FuncFParam={
  <basictype:BasicType> <ident:Ident> <exp: ("[" "]" <("[" <Exp> "]")*>)?> => {
    FuncFParam { <> }
  },
}

// Statement block Block → '{' { BlockItem } '}'
Block: Block = "{" <blockitem: (BlockItem)*> "}" => Block { <> };


// Statement block item BlockItem → Decl | Stmt
pub BlockItem: BlockItem = {
  Decl => BlockItem::Decl(<>),
  Stmt => BlockItem::Stmt(<>),
}

// Statement Stmt → LVal '=' Exp ';' | [Exp] ';' | Block
//             | 'if' '( Cond ')' Stmt [ 'else' Stmt ]
//             | 'while' '(' Cond ')' Stmt
//             | 'break' ';' | 'continue' ';'
//             | 'return' [Exp] ';'
// Need to handle else hanging problem
pub Stmt: Stmt={
  MStmt => <>,
  OStmt => <>,
}

pub MStmt: Stmt = {
  <lval:LVal> "=" <exp:Exp> ";" => Stmt::Assign(lval, exp),
  <exp:(Exp)?> ";" => Stmt::ExpSt(ExpSt{<>}),
  <b:Block> => Stmt::Block(b),
  "if" "(" <c:Cond> ")" <s1:MStmt> "else" <s2:MStmt> => {
    Stmt::If(c, Box::new(s1), Some(Box::new(s2)))
  },
  "while" "(" <c:Cond> ")" <s:MStmt> => Stmt::While(c, Box::new(s)),
  "break;" => Stmt::Break,
  "continue;" => Stmt::Continue,
  "return" <e:(Exp)?> ";" => Stmt::Return(Return{exp:e}),
}

pub OStmt: Stmt = {
  "if" "(" <c:Cond> ")" <s1: Stmt> => {
    Stmt::If(c, Box::new(s1), None)
  },
  "if" "(" <c:Cond> ")" <s1: MStmt> "else" <s2: OStmt> => {
    Stmt::If(c, Box::new(s1), Some(Box::new(s2)))
  },
  "while" "(" <c:Cond> ")" <s:OStmt> => Stmt::While(c, Box::new(s)),
}

// Expression Exp → AddExp 
pub Exp: Exp = <addexp:AddExp> => Exp{<>};

// Conditional expression Cond → LOrExp
pub Cond: Cond = <lorexp:LOrExp> => Cond{<>};

// Left value expression LVal → Ident {'[' Exp ']'}
pub LVal: LVal = <ident: Ident> <exp: ("[" <Exp> "]")*> => LVal { <> };

// Basic expression PrimaryExp → '(' Exp ')' | LVal | Number
pub PrimaryExp: PrimaryExp = {
  "(" <Exp> ")" => PrimaryExp::Exp(Box::new(<>)),
  LVal => PrimaryExp::LVal(<>),
  Number => PrimaryExp::Number(<>),
}

Int: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}

Float: f32 = {
  r"((([0-9]*[.][0-9]*([eE][+-]?[0-9]+)?)|([0-9]+[eE][+-]?[0-9]+))[fLlL]?)" => <>.parse::<f32>().unwrap(),
  r"(0[xX](([0-9A-Fa-f]*[.][0-9A-Fa-f]*([pP][+-]?[0-9]+)?)|([0-9A-Fa-f]+[pP][+-]?[0-9]+))[fLlL]?)" => {
        let float_literal: hexponent::FloatLiteral = <>.parse().unwrap();
        float_literal.convert::<f32>().inner()
    },
}

// value Number → IntConst | floatConst
pub Number: Number = {
  <n:Int> => Number::IntConst(n),
  <f:Float> => Number::FloatConst(f),
}

// Unary expression UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp
pub UnaryExp: UnaryExp = {
  PrimaryExp => UnaryExp::PrimaryExp(<>),
  <start:@L> <i: Ident> <end:@R> "(" ")" => UnaryExp::FuncCall(FuncCall { ident:i, exp: Vec::new(),  pos: SourcePos { start, end }}),
  <start:@L> <i: Ident> <end:@R> "(" <e: Exp> <mut exp: ("," <Exp>)*> ")" => {
    exp.insert(0, e);
    UnaryExp::FuncCall(FuncCall { ident:i, exp, pos: SourcePos { start, end }})
  },
  "+" <UnaryExp> => <>,
  "-" <uexp: UnaryExp> => UnaryExp::UnaryOp(UnaryOp::Neg, Box::new(uexp)),
  "!" <uexp: UnaryExp> => UnaryExp::UnaryOp(UnaryOp::Not, Box::new(uexp)),
}

// Multiplication and division modulus expression MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
pub MulExp: MulExp = {
  UnaryExp => MulExp::UnaryExp(<>),
  <me: MulExp> "*" <ue: UnaryExp> => {
    MulExp::MulUExp(Box::new(me), MulOp::Mul, ue)
  },
  <me: MulExp> "/" <ue: UnaryExp> => {
    MulExp::MulUExp(Box::new(me), MulOp::Div, ue)
  },
  <me: MulExp> "%" <ue: UnaryExp> => {
    MulExp::MulUExp(Box::new(me), MulOp::Mod, ue)
  },
}

// Addition and subtraction expression AddExp → MulExp | AddExp ('+' | '−') MulExp
pub AddExp: AddExp = {
  MulExp => AddExp::MulExp(<>),
  <ae: AddExp> "+" <me: MulExp> => {
    AddExp::AddMExp(Box::new(ae), AddOp::Add, me)
  },
  <ae: AddExp> "-" <me: MulExp> => {
    AddExp::AddMExp(Box::new(ae), AddOp::Sub, me)
  },
}

// Relational expression RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp
pub RelExp: RelExp = {
  AddExp => RelExp::AddExp(<>),
  <re: RelExp> "<" <ae: AddExp> => {
    RelExp::RelAExp(Box::new(re), RelOp::Lt, ae)
  },
  <re: RelExp> ">" <ae: AddExp> => {
    RelExp::RelAExp(Box::new(re), RelOp::Gt, ae)
  },
  <re: RelExp> "<=" <ae: AddExp> => {
    RelExp::RelAExp(Box::new(re), RelOp::Le, ae)
  },
  <re: RelExp> ">=" <ae: AddExp> => {
    RelExp::RelAExp(Box::new(re), RelOp::Ge, ae)
  },
}

// Equality expression EqExp → RelExp | EqExp ('==' | '!=') RelExp
pub EqExp: EqExp = {
  RelExp => EqExp::RelExp(<>),
  <ee: EqExp> "==" <re: RelExp> => {
    EqExp::EqRExp(Box::new(ee), EqOp::Eq, re)
  },
  <ee: EqExp> "!=" <re: RelExp> => {
    EqExp::EqRExp(Box::new(ee), EqOp::Ne, re)
  },
}

// Logical AND expression LAndExp → EqExp | LAndExp '&&' EqExp
LAndExp: LAndExp = {
  EqExp => LAndExp::EqExp(<>),
  <le: LAndExp> "&&" <ee: EqExp> => {
    LAndExp::LAndEExp(Box::new(le),ee)
  },
}

// Logical OR expression LOrExp → LAndExp | LOrExp '||' LAndExp
LOrExp: LOrExp = {
  LAndExp => LOrExp::LAndExp(<>),
  <loe: LOrExp> "||" <lae: LAndExp> => {
    LOrExp::LOrLExp(Box::new(loe),lae)
  },
}

// Constant expression ConstExp → AddExp
pub ConstExp: ConstExp = <addexp:AddExp> => ConstExp{<>};

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();
