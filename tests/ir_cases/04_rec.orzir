global @global_counter = i32 0x00000010
const @max_depth = i32 0x00000005

fn @deep_recursive(i32, i32) -> i32 {
^entry(i32 %depth, i32 %value):
    %max_depth = load i32, ptr @max_depth
    %cond_depth = icmp.sle i32 %depth, i32 %max_depth
    br i1 %cond_depth, ^compute(i32 %depth, i32 %value), ^exit(i32 %value)

^compute(i32 %0, i32 %1):
    %is_even = and i32 %1, i32 0x1
    %cond_even = icmp.eq i32 %is_even, i32 0x0
    br i1 %cond_even, ^even_path(i32 %0, i32 %1), ^odd_path(i32 %0, i32 %1)

^even_path(i32 %2, i32 %3):
    %half = sdiv i32 %3, i32 0x2
    %new_depth = add i32 %2, i32 0x01
    %rec_result = call i32 @deep_recursive(i32 %new_depth, i32 %half)
    jump ^merge(i32 %rec_result)

^odd_path(i32 %4, i32 %5):
    %double = mul i32 %5, i32 0x02
    %new_depth_ = add i32 %4, i32 0x01
    %rec_result_ = call i32 @deep_recursive(i32 %new_depth_, i32 %double)
    jump ^merge(i32 %rec_result_)

^merge(i32 %6):
    %global_counter = load i32, ptr @global_counter
    %updated = add i32 %6, i32 %global_counter
    jump ^exit(i32 %updated)

^exit(i32 %result):
    ret i32 %result
}

fn @main() -> i32 {
^entry:
    %start_value = add i32 0, i32 0x64
    %result = call i32 @deep_recursive(i32 0x0, i32 %start_value)
    ret i32 %result
}
